<html lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.js"></script>
    <script type="text/javascript" src="raphael-min.js"></script>

    <style>
      body{
        background: #F1EEEE;
      }
    </style>

  </head>
  <body>
    <script>
      var svgElem, svgWidth, svgHeight, circleMatrix;
      var audioContext, audioVolumeControl, noiseVolumeControl, audioXCoor, audioYCorr;
      var clickOn = false, broadcastTimer;
      var MAX_NOISE_GAIN = 0.5;
      var MAX_AUDIO_GAIN = 5;
      var COLORS = ['#F25A4C', '#FB2C24', '#8B312C', '#9D175B', '#7D7C82', '#807340', '#C9B82C', '#32A853', '#5F74BC', '#C0C8E4', '#3071FC'];
      var BOX_WIDTH = 100;
      var OUTER_CIRCLE_RADIUS = 30;
      var OUTER_CIRCLE_STROKE_WIDTH = 5;
      var MAX_INNER_CIRCLE_RADIUS = 25;
      var MIN_INNER_CIRCLE_RADIUS = 10;
      var MAX_GROWTH_RADIUS = 52;
      var COLOR_TIME = 50;
      var GROWTH_TIME = 300;
      var RESET_TIME = 2000;
      var BROADCAST_FREQUENCY = 700;
      var BROADCAST_STROKE_WIDTH = 2;
      var BROADCAST_TIME = 3000;
      var MAX_BROADCAST_RADIUS_IN_BOX_WIDTHS = 3;
      var BROADCAST_NEIGHBOUR_OPACITY = 0.4;
      var BROADCAST_NEIGHBOUR_MOVE_TIME = 1000;

      function Circle(x, y) {
        this.x = x;
        this.y = y;
        this.innerCircleRadius = (MAX_INNER_CIRCLE_RADIUS - MIN_INNER_CIRCLE_RADIUS) * Math.random() + MIN_INNER_CIRCLE_RADIUS;
        this.outerCircleColor = COLORS[Math.floor(COLORS.length  * Math.random())];
        this.innerCircleColor = COLORS[Math.floor(COLORS.length  * Math.random())];

        this.drawCircle();
        this.setupOnHover();
        this.setupOnClick();
      };

      Circle.prototype.setupOnClick = function(){
          var that = this;
          this.svgSet.click(function(){
            clickOn = true;
            that.pushNeighbours(BOX_WIDTH + OUTER_CIRCLE_RADIUS);
            that.startBroadcast();
          });
      };

      Circle.prototype.setupOnHover = function(){
          var that = this;
          that.svgSet.hover(function() {
            that.outerCircle.stop().animate({r: MAX_GROWTH_RADIUS}, GROWTH_TIME, 'easeIn');
            that.innerCircle.stop().animate({r: OUTER_CIRCLE_RADIUS}, GROWTH_TIME,'easeIn');
            that.colorOn();
          },
          function() {
            that.reset();
            if(clickOn) that.resetNeighbours();
          });
      };

      Circle.prototype.drawCircle = function(){
        this.outerCircle = svgElem.circle(this.x, this.y, OUTER_CIRCLE_RADIUS);
        this.outerCircle.attr({
          "stroke": "E0DCDC",
          "stroke-width": OUTER_CIRCLE_STROKE_WIDTH
        });

        this.innerCircle = svgElem.circle(this.x, this.y, this.innerCircleRadius);
        this.innerCircle.attr({
          stroke: "none",
          fill: "E0DCDC"
        });

        hoverArea = svgElem.rect(this.x - BOX_WIDTH/2, this.y-BOX_WIDTH/2, BOX_WIDTH, BOX_WIDTH);
        hoverArea.attr({stroke: "none",
                fill:   "#f00",
                "fill-opacity": 0});

        if(this.x === audioXCoor && this.y === audioYCoor){
          hoverArea.attr({stroke: "#000"});
        }

        this.svgSet = svgElem.set();
        this.svgSet.push(this.outerCircle, this.innerCircle, hoverArea);
      };

      Circle.prototype.colorOn = function(opacity){
        opacity = opacity || 1;
        this.outerCircle.animate({stroke: this.outerCircleColor, 'opacity': opacity}, COLOR_TIME);
        this.innerCircle.animate({fill: this.innerCircleColor, 'opacity': opacity}, COLOR_TIME);
      };

      Circle.prototype.colorOff = function(){
        this.outerCircle.animate({stroke: '#E0DCDC', 'opacity': 1}, RESET_TIME);
        this.innerCircle.animate({fill: "#E0DCDC", 'opacity': 1}, RESET_TIME);
      };

      Circle.prototype.pushNeighbours = function(desiredRadius){
        this.callOnNeighbours(1, this.pushedByNeighbour, this, desiredRadius);
      };

      Circle.prototype.pushedByNeighbour = function(neighbour, desiredDistance){
        var xDistance = this.x - neighbour.x;
        var yDistance = this.y - neighbour.y;

        var newXDistance = desiredDistance * (xDistance == 0 ? 0 : yDistance == 0 ? 1 : 0.70710678119);
        var newYDistance = desiredDistance * (yDistance == 0 ? 0 : xDistance == 0 ? 1 : 0.70710678119);

        var newXCoor = neighbour.x + newXDistance * (xDistance == 0 ? 0 : xDistance / Math.abs(xDistance));
        var newYCoor = neighbour.y + newYDistance * (yDistance == 0 ? 0 : yDistance / Math.abs(yDistance));

        var anim = Raphael.animation({'cx': newXCoor, 'cy': newYCoor}, BROADCAST_NEIGHBOUR_MOVE_TIME, 'bounce');
        this.svgSet.stop().animate(anim);

        this.colorOn(BROADCAST_NEIGHBOUR_OPACITY);
      };

      Circle.prototype.resetNeighbours = function(){
          this.callOnNeighbours(1, this.reset);
      };

      Circle.prototype.reset = function(){
        this.outerCircle.stop().animate({r: OUTER_CIRCLE_RADIUS}, RESET_TIME);
        this.innerCircle.stop().animate({r: this.innerCircleRadius}, RESET_TIME);
        this.colorOff();

        this.svgSet.animate({
          cx: this.x,
          cy: this.y
        }, RESET_TIME);

        this.stopBroadcast();
      };

      Circle.prototype.startBroadcast = function(){
        var that = this;
        that.stopBroadcast();
        that.sendBroadcast();
        broadcastTimer = setInterval(function(){that.sendBroadcast()}, BROADCAST_FREQUENCY);
      };

      Circle.prototype.stopBroadcast = function(){
        clearInterval(broadcastTimer);
      };

      Circle.prototype.sendBroadcast = function(){
        var broadcastCircle = svgElem.circle(this.outerCircle.attr('cx'), this.outerCircle.attr('cy'), this.outerCircle.attr('r'));
        broadcastCircle.attr({
          "stroke": this.outerCircleColor,
          "stroke-width": BROADCAST_STROKE_WIDTH
        });

        broadcastCircle.animate({
          r: MAX_BROADCAST_RADIUS_IN_BOX_WIDTHS * BOX_WIDTH,
          opacity: 0
        }, BROADCAST_TIME, function(){
          this.remove();
        });

        //Precompute broadcast effect on neighbours
        //using linear easing, broadcast wave radius at time t =>
        //r(t) = (MAX_BROADCAST_RADIUS_IN_BOX_WIDTHS * BOX_WIDTH - this.outerCircle.attr('r")) * t / BROADCAST_TIME + this.outerCircle.attr('r")
        //solving for t, given a radius R=>
        //t = (R - this.outerCircle.attr('r")) * BROADCAST_TIME / (MAX_BROADCAST_RADIUS_IN_BOX_WIDTHS * BOX_WIDTH - this.outerCircle.attr('r"))
      };

      Circle.prototype.callOnNeighbours = function(maxDegreesOfSeperation, functionToCall){
        maxDegreesOfSeperation = maxDegreesOfSeperation || 1

        var args = [];
        for(var i = 2; i < arguments.length; i++)
        {
          args.push(arguments[i]);
        }

        var xIndex = this.x/BOX_WIDTH - 0.5;
        var yIndex = this.y/BOX_WIDTH - 0.5;

        //STARTING TOP LEFT CORNER OF NEIGHBOURS, LOOP THROUGH EACH LEVEL
        for(var xLevel = -maxDegreesOfSeperation; xLevel <= maxDegreesOfSeperation; xLevel++){
          if(xIndex + xLevel < 0 || xIndex + xLevel > circleMatrix.length - 1) continue;

          for(var yLevel = -maxDegreesOfSeperation; yLevel <= maxDegreesOfSeperation; yLevel++){
            if(yIndex + yLevel < 0 || yIndex + yLevel > circleMatrix[xIndex + xLevel].length - 1) continue;

            functionToCall.apply(circleMatrix[xIndex + xLevel][yIndex + yLevel], args);
          }
        }
      }

      function initSVG(){
        svgWidth = window.innerWidth;
        svgHeight = window.innerHeight;
        svgElem = Raphael(0, 0, svgWidth, svgHeight);

        var randomXCoor = svgWidth*Math.random();
        var randomYCoor = svgHeight*Math.random();
        audioXCoor = randomXCoor - (randomXCoor - BOX_WIDTH/2) % BOX_WIDTH;
        audioYCoor = randomYCoor - (randomYCoor - BOX_WIDTH/2) % BOX_WIDTH;
        console.log("random audio source coor:", audioXCoor, audioYCoor);

        circleMatrix = new Array(Math.ceil(svgWidth/BOX_WIDTH));

        for(var x = BOX_WIDTH/2; x < svgWidth; x += BOX_WIDTH)
        {
          circleMatrix[x/BOX_WIDTH - 0.5] = new Array(Math.ceil(svgHeight/BOX_WIDTH));
          for(var y = BOX_WIDTH/2; y < svgHeight; y += BOX_WIDTH)
          {
            circleMatrix[x/BOX_WIDTH - 0.5][y/BOX_WIDTH - 0.5] = new Circle(x, y, svgElem);
          }
        }
      };

      function initAudio(){
        audioContext = new webkitAudioContext();

        //loadAudio();
        //loadNoise();

        $('svg').mousemove(function(e){
            if(audioVolumeControl){
              audioVolumeControl.gain.value = MAX_AUDIO_GAIN * (1 - Math.abs(e.pageX - audioXCoor)/svgWidth);
            }
            if(noiseVolumeControl){
              noiseVolumeControl.gain.value = MAX_NOISE_GAIN * Math.abs(e.pageY - audioYCoor)/svgHeight;
            }
        });
      };

      function loadAudio(){
        var request = new XMLHttpRequest();
        request.open('get',
          'MLKDream.ogg',
          true);
        request.responseType = "arraybuffer";

        request.onload = function() {
          audioContext.decodeAudioData(
            request.response,
            function(incomingBuffer) {
              playAudio(incomingBuffer); // Not defined yet
            },
            function (e) {console.log(e);}
          );
        };
        request.send();
      };

      function playAudio(buffer) {
        var source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.loop = true;

        audioVolumeControl = audioContext.createGainNode();
        source.connect(audioVolumeControl);
        audioVolumeControl.connect(audioContext.destination);

        source.noteOn(0);
      };

      function loadNoise(){
        var request = new XMLHttpRequest();
        request.open('get',
          'white-noise.mp3',
          true);
        request.responseType = "arraybuffer";

        request.onload = function() {
          audioContext.decodeAudioData(
            request.response,
            function(incomingBuffer) {
              playNoise(incomingBuffer); // Not defined yet
            },
            function (e) {console.log(e);}
          );
        };
        request.send();
      };

      function playNoise(buffer) {
        var source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.loop = true;

        noiseVolumeControl = audioContext.createGainNode();
        noiseVolumeControl.gain.value = MAX_NOISE_GAIN;
        source.connect(noiseVolumeControl);
        noiseVolumeControl.connect(audioContext.destination);

        source.noteOn(0);
      };

      $(function(){
        initSVG();
        initAudio();
      });
    </script>
  </body>
</html>
